

/**********************************************************************************************************************
 * Includes
 *********************************************************************************************************************/
#include "Com_Prv.h"
#include "Com_Prv_Inl.h"

/**********************************************************************************************************************
 * Local Prototypes
 *********************************************************************************************************************/
#if defined(COM_RxIPduTimeout) || defined(COM_RxSigUpdateTimeout) || defined(COM_RxSigGrpUpdateTimeout)
LOCAL_INLINE FUNC(void, COM_CODE) Com_Prv_RxTimeoutProcessing(
                                                        VAR(PduIdType, AUTOMATIC)   RxPduId,
                                                        VAR(boolean, AUTOMATIC)     RxIndication_b
                                                             );
#endif /* #if defined(COM_RxIPduTimeout) || defined(COM_RxSigUpdateTimeout) || defined(COM_RxSigGrpUpdateTimeout) */

#ifdef COM_RxIPduTimeout
LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_IPduBasedTimeoutMonitoring(
                                                        VAR(PduIdType, AUTOMATIC)   RxPduId,
                                                        VAR(boolean, AUTOMATIC)     RxIndication_b
                                                                       );

LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_IPduBasedSigTimeoutAction(
                                                        VAR(PduIdType, AUTOMATIC)   RxPduId
                                                                      );

#ifdef COM_RX_SIGNALGROUP
LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_IPduBasedSigGrpTimeoutAction(
                                                        VAR(PduIdType, AUTOMATIC)   RxPduId
                                                                         );
#endif /* #ifdef COM_RX_SIGNALGROUP */
#endif /* #ifdef COM_RxIPduTimeout */

#ifdef COM_RxSigUpdateTimeout
LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_SigBasedTimeoutMonitoring(
                                                        VAR(PduIdType, AUTOMATIC)   RxPduId
                                                                      );
#endif /* #ifdef COM_RxSigUpdateTimeout */

#ifdef COM_RxSigGrpUpdateTimeout
LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_SigGrpBasedTimeoutMonitoring(
                                                        VAR(PduIdType, AUTOMATIC)   RxPduId
                                                                         );
#endif /* #ifdef COM_RxSigGrpUpdateTimeout */

/**********************************************************************************************************************
 * Global functions (declared in header files )
 *********************************************************************************************************************/
/**********************************************************************************************************************
 Function name    : Com_InternalMainFunctionRx
 Syntax           : void Com_InternalMainFunctionRx( Com_MainFuncType RxMainFuncId )
 Description      : Service to perform the processing of the AUTOSAR COM receive processing that
                    are not directly initiated by the calls from the RTE and PDU-R.
 Parameter        : RxMainFuncId - Internal Rx-ComMainFunction Id
 Return value     : None
 *********************************************************************************************************************/
#define COM_START_SEC_CODE
#include "Com_MemMap.h"
/* HIS METRIC CALLS, LEVEL VIOLATION IN Com_InternalMainFunctionRx:
   Com_InternalMainFunctionRx function contains necessary function calls and simple "if" and "else if" statements.
   HIS metric compliance would decrease readability and maintainability */
FUNC(void, COM_CODE) Com_InternalMainFunctionRx( VAR(Com_MainFuncType,AUTOMATIC) RxMainFuncId )
{
    Com_RxIpduConstPtrType              RxIPduConstPtr;
    Com_RxIpduRamPtrType                RxIpduRamPtr;
    VAR(uint16_least, AUTOMATIC)        Idx_Pdu_ui;
    VAR(Com_IpduIdType,AUTOMATIC)       StartIPduId;    /* Start RxIPduId to be processed */
    VAR(Com_IpduIdType,AUTOMATIC)       EndIPduId;      /* Last  RxIPduId to be processed */

    /* DET is not checked for RxMainFuncId, as this is an internal Id generated by the Com */
    /* [SWS_Com_00664] A call to Com_MainFunctionRx shall simply return if the AUTOSAR COM module was not
     * previously initialized with a call to Com_Init. */
    if (
#if(COM_CONFIGURATION_USE_DET == STD_ON)
        Com_Prv_DETCheck_Void(COMServiceId_MainFunctionRx)
#else
        (Com_Uninit_Flag == COM_INIT)
#endif
        )
    {
        /* Get RxIPdu-Ids which shall be processed for given ComMainFunction */
        StartIPduId    = COM_GET_MAINFUNCTION_CFG( RxMainFuncId ).StartIPduId;
        EndIPduId      = StartIPduId + COM_GET_MAINFUNCTION_CFG( RxMainFuncId ).NumOfIpdus;

        RxIPduConstPtr = COM_GET_RX_IPDU_CONSTDATA(StartIPduId);
        RxIpduRamPtr   = &COM_GET_RXPDURAM_S(StartIPduId);

        for (Idx_Pdu_ui = (uint16_least)StartIPduId; Idx_Pdu_ui < (uint16_least)EndIPduId; Idx_Pdu_ui++)
        {
            /* Check for Ipdu Group is Started/Stopped */
            if(Com_CheckRxIPduStatus((PduIdType)Idx_Pdu_ui))
            {
#if defined(COM_RxIPduDeferredProcessing) || \
    defined(COM_RxIPduTimeout) || defined(COM_RxSigUpdateTimeout) || defined(COM_RxSigGrpUpdateTimeout)
                VAR(boolean,AUTOMATIC)  RxIndication_b;

                /* RxIndication() status has to be stored into local variable here only,
                 * so as to process its timeout later */
                RxIndication_b = Com_GetRamValue(RXIPDU,_INDICATION,RxIpduRamPtr->RxFlags);
#endif

#ifdef COM_RxIPduDeferredProcessing
                /* For an Ipdu with Immediate Signal processing, the _INDICATION flag will be reset here */
                if (Com_GetValue(RXIPDU,_SIGPROC,RxIPduConstPtr->rxIPduFields) == COM_IMMEDIATE)
#endif
                {
                    Com_SetRamValue(RXIPDU,_INDICATION,RxIpduRamPtr->RxFlags,COM_FALSE);
                }
#ifdef COM_RxIPduDeferredProcessing
                else
                {
                    /* For an IPdu with COM_DEFERRED signal processing,
                     * check if there is any pending RxIndication to be processesed. */
                    if (RxIndication_b != COM_FALSE)
                    {
                        VAR(PduInfoType, COM_VAR)   ComRxIPduInfo;

                        /* Copy the data from IPdu buffer to another buffer
                         * This is required for data consistency as it is possible that IPdu buffer is updated
                         * by Com_RxIndication(), when it is being processed
                         * Since all the IPdus are processed sequentially, only one common buffer is sufficient
                         */
                        SchM_Enter_Com_RxPduBuffer();

                        ComRxIPduInfo.SduDataPtr = COM_GET_DEFERREDBUFFER(RxMainFuncId);
                        ComRxIPduInfo.SduLength  = RxIpduRamPtr->RxIPduLength;

                        Com_ByteCopy(ComRxIPduInfo.SduDataPtr, RxIPduConstPtr->BuffPtr, ComRxIPduInfo.SduLength);

                        /* Reset the flag after checking the flag
                         * In case of defered processing, the flag should be reset under protection */
                        Com_SetRamValue(RXIPDU,_INDICATION,RxIpduRamPtr->RxFlags,COM_FALSE);

                        SchM_Exit_Com_RxPduBuffer();

                        Com_ProcessRxIPdu((PduIdType)Idx_Pdu_ui, &ComRxIPduInfo);
                    }
                }
#endif /* #ifdef COM_RxIPduDeferredProcessing */

#if defined(COM_RxIPduTimeout) || defined(COM_RxSigUpdateTimeout) || defined(COM_RxSigGrpUpdateTimeout)

                /* Reception Deadline Monitoring */
                Com_Prv_RxTimeoutProcessing((PduIdType)Idx_Pdu_ui, RxIndication_b);

#endif /* #if defined(COM_RxIPduTimeout) || defined(COM_RxSigUpdateTimeout) || defined(COM_RxSigGrpUpdateTimeout) */

            }/* End of check for Ipdu Group is Started/Stopped */

            RxIPduConstPtr++;
            RxIpduRamPtr++;
        } /* End of for loop */
    }/* End of DET Check or Com initialization status */

} /* End of Com_InternalMainFunctionRx */
#define COM_STOP_SEC_CODE
#include "Com_MemMap.h"

#if defined(COM_RxIPduTimeout) || defined(COM_RxSigUpdateTimeout) || defined(COM_RxSigGrpUpdateTimeout)
/**********************************************************************************************************************
 Function name    : Com_Prv_RxTimeoutProcessing
 Syntax           : void Com_Prv_RxTimeoutProcessing( VAR(PduIdType, AUTOMATIC)   RxPduId,
                                                      VAR(boolean, AUTOMATIC)     RxIndication_b )
 Description      : Performs Reception Deadline Monitoring
 Parameter        : RxPduId         - Internal Rx-IPdu Id
                    RxIndication_b  - latest RxIndication status
 Return value     : None
 *********************************************************************************************************************/
/* HIS METRIC CALLS VIOLATION IN Com_Prv_RxTimeoutProcessing:
   Com_Prv_RxTimeoutProcessing function contains necessary function calls statements.
   HIS metric compliance would decrease readability and maintainability */
LOCAL_INLINE FUNC(void, COM_CODE) Com_Prv_RxTimeoutProcessing( VAR(PduIdType, AUTOMATIC)   RxPduId,
                                                               VAR(boolean, AUTOMATIC)     RxIndication_b )
{
    Com_RxIpduConstPtrType  RxIPduConstPtr;
#if defined(COM_SIGNALGATEWAY) || defined(COM_SIGNALGROUPGATEWAY)
    Com_RxIpduRamPtrType    RxIpduRamPtr;
#endif
    /* updated any timed out gateway rx-signals/signal groups? */
    VAR(boolean, AUTOMATIC) isGwSigUpdated_b;

    /* Check if deadline monitoring is enabled for IpduGroup & configured for IPdu. */
    if (COM_CheckRxIPduDMStatus(RxPduId))
    {
        RxIPduConstPtr   = COM_GET_RX_IPDU_CONSTDATA(RxPduId);

#if defined(COM_SIGNALGATEWAY) || defined(COM_SIGNALGROUPGATEWAY)
        RxIpduRamPtr     = &COM_GET_RXPDURAM_S(RxPduId);
#endif

#ifdef COM_RxIPduTimeout

        /* [SWS_Com_00290] The AUTOSAR COM module shall perform an I-PDU based
         * reception deadline monitoring for signals without an update-bit. */
        isGwSigUpdated_b = Com_Prv_IPduBasedTimeoutMonitoring( (PduIdType)RxPduId, RxIndication_b );

#else
        isGwSigUpdated_b = COM_FALSE;

#endif /* #ifdef COM_RxIPduTimeout */

#ifdef COM_RxSigUpdateTimeout

        /* Start timeout monitoring for signals with update-bit */
        if (RxIPduConstPtr->SignalTimeout_Ref != NULL_PTR)
        {
            isGwSigUpdated_b = Com_Prv_SigBasedTimeoutMonitoring( (PduIdType)RxPduId ) || isGwSigUpdated_b;
        }
#endif /* #ifdef COM_RxSigUpdateTimeout */

#ifdef COM_RxSigGrpUpdateTimeout

        /* Start timeout monitoring for signal groups with update-bit */
        if (RxIPduConstPtr->SignalGrpTimeout_Ref != NULL_PTR)
        {
            isGwSigUpdated_b = Com_Prv_SigGrpBasedTimeoutMonitoring( (PduIdType)RxPduId ) || isGwSigUpdated_b;
        }
#endif /* #ifdef COM_RxSigGrpUpdateTimeout */

#if defined(COM_SIGNALGATEWAY) || defined(COM_SIGNALGROUPGATEWAY)
        /* This part of code updates the Rx Gateway queue,
         * If any gateway rx-signal in the Ipdu were updated by one of the below means
         * 1. Rx Ipdu timeout leading to a signal update
         * 2. Signal timeout leading to a signal update
         */
        /* MR12 RULE 13.5 VIOLATION: Below conditional statement access RAM, use of intermediate variables
           to store and read here, may read obsolete value. Evaluation(or no evaluation) shall not impact
           the system behaviour. Hence suppressed. */
        if ((isGwSigUpdated_b) &&
            (Com_GetRamValue(RXIPDU,_GWPDU_TOBEPROCESSED,RxIpduRamPtr->RxFlags) != COM_TRUE))
        {

            SchM_Enter_Com_RxSigGwQueueProtArea();
            /* There is a new reception of Ipdu caused a new update on the Signal,
             * Hence set the flag to process in next Com_MainfunctionRouteSignals
             * Once the Ipdu is processed, this flag will hold COM_TRUE in Com_MainfunctionRouteSignals
             * If any new receptions are invoked on the same Ipdu before the next processing is done,
             * 1. Signal buffers are updated
             * 2. Queue is not updated */
            (void)Com_WriteSigGwReceiveQueue((PduIdType)RxPduId);
            /* There is a new reception of Ipdu/ Ipdu timeout caused a new update on the Signal,
             * Hence set the flag to process in next Com_MainfunctionRouteSignals
             * Once the Ipdu is processed, this flag will hold COM_TRUE in Com_MainfunctionRouteSignals
             * If any new receptions are invoked on the same Ipdu before the next processing is done,
             * 1. Signal buffers are updated
             * 2. Queue is not updated */
            Com_SetRamValue(RXIPDU,_GWPDU_TOBEPROCESSED,RxIpduRamPtr->RxFlags,COM_TRUE);
            SchM_Exit_Com_RxSigGwQueueProtArea();
        }
#else
        (void)isGwSigUpdated_b;
#endif /* #if defined COM_SIGNALGATEWAY || defined COM_SIGNALGROUPGATEWAY */

    } /* End of check for reception timeout monitoring */
} /* End of Com_Prv_RxTimeoutProcessing */
#endif /* #if defined(COM_RxIPduTimeout) || defined(COM_RxSigUpdateTimeout) || defined(COM_RxSigGrpUpdateTimeout) */


#ifdef COM_RxIPduTimeout
/**********************************************************************************************************************
 Function name    : Com_Prv_IPduBasedTimeoutMonitoring
 Syntax           : boolean Com_Prv_IPduBasedTimeoutMonitoring(
                                                    VAR(PduIdType, AUTOMATIC)   RxPduId,
                                                    VAR(boolean, AUTOMATIC)     RxIndication_b
                                                              )
 Description      : Service to perform rx-IPdus timeout processing
 Parameter        : RxPduId         - Internal Rx-IPdu Id
                    RxIndication_b  - latest RxIndication status
 Return value     : true - if any Gw-signal/signalGroup are updated, otherwise return false.
 *********************************************************************************************************************/
LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_IPduBasedTimeoutMonitoring(
                                                            VAR(PduIdType, AUTOMATIC)   RxPduId,
                                                            VAR(boolean, AUTOMATIC)     RxIndication_b
                                                                       )
{
    Com_RxIpduConstPtrType      RxIPduConstPtr;
    Com_RxIpduRamPtrType        RxIpduRamPtr;
    VAR(uint16, AUTOMATIC)      rxTimeOutVal_u16;
    VAR(boolean, AUTOMATIC)     isGwSigUpdated_b; /* updated any timed out gateway rx-signals/signal groups? */
#ifdef COM_RxIPduTimeoutNotify
    VAR(boolean, AUTOMATIC)     CallTONotify_b;

    CallTONotify_b   = COM_FALSE; /* Initialise the CallTONotify_b flag to false */
#endif

    isGwSigUpdated_b = COM_FALSE;

    RxIPduConstPtr   = COM_GET_RX_IPDU_CONSTDATA(RxPduId);
    RxIpduRamPtr     = &COM_GET_RXPDURAM_S(RxPduId);

    /* Load receive time out */
    rxTimeOutVal_u16 = COM_GET_RXIPDU_TIMEOUT(RxPduId, RxIPduConstPtr);

    /* Reload Ipdu timeout value on every reception */
    if (RxIndication_b != COM_FALSE)
    {
        /* FC_VariationPoint_START */
#if (COM_ENABLE_JITTERFLITER == STD_ON)
        /* CC requirements:
         * An extra cycle is added to the timeout value after a PDU has been received incase filter is
         * ON Provides a chance incase of jitter( extra cycle is added in normal case and hence
         * if JITTERFILTER is enabled extra two cycles are added)
         */
        RxIpduRamPtr->RxTicks_u16 =
                (rxTimeOutVal_u16 == 0) ? COM_RXTIMER_MAX : (rxTimeOutVal_u16 + 2u);
#else
        /* FC_VariationPoint_END   */
        /* Extra cycle is added to prevent early timeouts */
        RxIpduRamPtr->RxTicks_u16 =
                (rxTimeOutVal_u16 == 0) ? COM_RXTIMER_MAX : (rxTimeOutVal_u16 + 1u);
        /* FC_VariationPoint_START */
#endif /* #ifdef COM_ENABLE_JITTERFLITER */
        /* FC_VariationPoint_END   */
    }

    /* If timeout is disabled for an IPdu (i.e, ComTimeOut = 0) then
     * RxTicks will be loaded with COM_RXTIMER_MAX (0xFFFF).
     * Reduce Tick Timeout only if timeout is applicable (i.e., other than COM_RXTIMER_MAX).
     */
    SchM_Enter_Com_RxSigBuff(MAINFUNCTIONRX);
    /* Not to go less than ZERO */
    if ((RxIpduRamPtr->RxTicks_u16 != COM_RXTIMER_MAX) && (RxIpduRamPtr->RxTicks_u16 != 0))
    {
        --RxIpduRamPtr->RxTicks_u16;
    }
    /* IPDU has timed out */
    if (RxIpduRamPtr->RxTicks_u16 == 0x00)
    {
        /* Reload the timer upon time out */
        RxIpduRamPtr->RxTicks_u16 = rxTimeOutVal_u16;

        /* Perform timeout actions for Signals without update bit position */
        isGwSigUpdated_b = Com_Prv_IPduBasedSigTimeoutAction( RxPduId );

#ifdef COM_RX_SIGNALGROUP
        /* Perform timeout actions for Signal groups without update bit position */
        isGwSigUpdated_b = Com_Prv_IPduBasedSigGrpTimeoutAction( RxPduId ) || isGwSigUpdated_b;
#endif

#ifdef COM_RxIPduTimeoutNotify
        /* Set the Timeout notification flag to TRUE, as the Rx Ipdu timer as elapsed.
         * But call the TO notification callback from outside the SchM_Enter_Com_RxSigBuff() lock  */
        CallTONotify_b = COM_TRUE;
#endif /* #ifdef COM_RxIPduTimeoutNotify */

    } /* if (RxIpduRamPtr->RxTicks_u16 == 0x00) */
    SchM_Exit_Com_RxSigBuff(MAINFUNCTIONRX);

#ifdef COM_RxIPduTimeoutNotify
    /* Call the notification function for IPDU, signals & signal groups (without update-bit) */
    if ((CallTONotify_b != COM_FALSE) &&
        (RxIPduConstPtr->TimeOutNotification_Cbk != NULL_PTR))
    {
        /* The following function is generated function in com_cfg.c file
         * This function calls the error notification functions of IPDU, signals & signal groups
         * (without update-bit)
         */
        RxIPduConstPtr->TimeOutNotification_Cbk();
    }
#endif /* #ifdef COM_RxIPduTimeoutNotify */

    return isGwSigUpdated_b;

} /* End of Com_Prv_IPduBasedTimeoutMonitoring */
#endif /* #ifdef COM_RxIPduTimeout */


/**********************************************************************************************************************
 Function name    : Com_Prv_IPduBasedSigTimeoutAction
 Syntax           : boolean Com_Prv_IPduBasedSigTimeoutAction( PduIdType RxPduId )
 Description      : Service to execute rx-signal timeout action
 Parameter        : RxPduId - Internal Rx-IPdu Id
 Return value     : true - if any Gw-signal/signalGroup are updated, otherwise return false.
 *********************************************************************************************************************/
#ifdef COM_RxIPduTimeout
LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_IPduBasedSigTimeoutAction( VAR(PduIdType, AUTOMATIC)   RxPduId )
{
    Com_RxIpduConstPtrType                  RxIPduConstPtr;
    Com_RxSigConstPtrType                   RxSigConstPtr;
#if defined(COM_SIGNALGATEWAY) || (defined (COM_RxFilters) && defined (COM_F_MASKEDNEWDIFFERSOLD))
    Com_RxSigRamPtrType                     RxSigRamPtr;
#endif
    VAR(uint16_least, AUTOMATIC)            Idx_Sig_ui;
    VAR(Com_MainFuncType,AUTOMATIC)         RxMainFuncId;
    /* updated any timed out gateway rx-signals ? */
    VAR(boolean, AUTOMATIC)                 isGwSigUpdated_b;

    isGwSigUpdated_b = COM_FALSE;

    RxIPduConstPtr   = COM_GET_RX_IPDU_CONSTDATA(RxPduId);

    RxMainFuncId     = RxIPduConstPtr->MainFunctionRef;

    /* Set the signal flags to indicate timeout
     * When the signal is read using function Com_ReceiveSignal() , if signal is timed out then
     * either previous value or init value is returned based on the action configured
     */
    RxSigConstPtr = COM_GET_RXSIG_CONSTDATA(RxIPduConstPtr->RxSigId_Index);

#if defined(COM_SIGNALGATEWAY) || (defined (COM_RxFilters) && defined (COM_F_MASKEDNEWDIFFERSOLD))
    RxSigRamPtr   = &COM_GET_RXSIGNALFLAG(RxIPduConstPtr->RxSigId_Index);
#endif
    for (Idx_Sig_ui = RxIPduConstPtr->No_Of_Sig_Ref; Idx_Sig_ui != 0u; Idx_Sig_ui--)
    {
        /* Signal with update-bit have seperate timeout handling
         * Signals without update-bit are marked as timed out, when IPdu times out.
         */
#ifdef COM_RxSigUpdateBit
        if (Com_GetValue(GEN,_UPDBITCONF,RxSigConstPtr->General) == COM_FALSE)
#endif
        {
            /* Now check if the RxTimeout action is = COM_REPLACE */
            if (Com_GetValue(RXSIG,_TOACTION,RxSigConstPtr->rxSignalFields))
            {
                VAR(Com_SigMaxType, AUTOMATIC) RxSigVal;
#if (defined(COM_RXSIG_INT64) || defined(COM_RXSIG_FLOAT64SUPP))
                VAR(uint8,AUTOMATIC)           Type;

                Type     = Com_GetValue(GEN,_TYPE,RxSigConstPtr->General);
#endif
                RxSigVal = (Com_SigMaxType)RxSigConstPtr->Init_Val;

/* FC_VariationPoint_START */
#ifdef COM_RXSIG_FLOAT64SUPP
                if (Type == COM_FLOAT64)
                {
                    /* For float64 signals, RxSigConstPtr->Init_Val holds index to
                     * float array holding init values. */
                    COM_GET_SIGTYPEFLOAT64_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index) =
                                                         Com_getfloat64InitValue(RxSigVal);
                }
                else
#endif /* #ifdef COM_RXSIG_FLOAT64SUPP */
/* FC_VariationPoint_END */
                {

#ifdef COM_RXSIG_INT64
                    /* [SWS_Com_00723] The AUTOSAR COM module shall extend the init value
                     * (ComSignalInitValue) of a signal to the size of its ComSignalType.
                     * Init_Val by default will be sign extended only for 32bits.
                     * Currently for COM_SINT64 signal types, if the signal is of Negative,
                     * it is required to perform the sign extension till 64bits explicitly. */
                    RxSigVal = (Type == COM_SINT64) ? (Com_SigMaxType)((sint64)((sint32)RxSigVal)) : RxSigVal;
#endif
                    Com_UpdateRxSignalBuffer(RxSigConstPtr, RxSigVal, RxMainFuncId);
                }
            }
#ifdef COM_SIGNALGATEWAY
            /* This part of code updates the Rx Gateway queue If the signal/Ipdu is timed out */
            if(Com_GetValue(RXSIG,_ISGWSIG,RxSigConstPtr->rxSignalFields) != COM_FALSE)
            {
                /* If the signal is updated after the last call of Com_MainfunctionRouteSignals
                 * because of the Ipdu Timeout
                 * 1. The fill bit per signal has to be set
                 * 2. Queue entry has to be done for the signal
                 * For the further receptions of the signal, Queue and signal fill bit are not set */
                Com_SetRamValue(RXSIG,_SIGNALFILLBIT,RxSigRamPtr->rxSigRAMFields,COM_TRUE);

                /* Flag will tell if any signals in the Ipdu are updated */
                isGwSigUpdated_b = COM_TRUE;
            }
#endif /* #ifdef COM_SIGNALGATEWAY */

#if defined (COM_RxFilters) && defined (COM_F_MASKEDNEWDIFFERSOLD)
            /* [SWS_Com_00793] For a signal with a configured reception filter
             * MASKED_NEW_DIFFERS_MASKED_OLD, the AUTOSAR COM module shall treat the
             * first value received for this signal after a reception deadline monitoring timeout
             * occurred for this signal the same way as if the value has passed the filter criteria. */
            Com_SetRamValue(RXSIG,_DMFILTERING,RxSigRamPtr->rxSigRAMFields,COM_TRUE);
#endif /* #if defined (COM_RxFilters) && defined (COM_F_MASKEDNEWDIFFERSOLD) */
        }

        RxSigConstPtr++;
#if defined(COM_SIGNALGATEWAY) || (defined (COM_RxFilters) && defined (COM_F_MASKEDNEWDIFFERSOLD))
        RxSigRamPtr++;
#endif
    }

    return isGwSigUpdated_b;

} /* End of Com_Prv_IPduBasedSigTimeoutAction */
#endif /* #ifdef COM_RxIPduTimeout */


/**********************************************************************************************************************
 Function name    : Com_Prv_IPduBasedSigGrpTimeoutAction
 Syntax           : boolean Com_Prv_IPduBasedSigGrpTimeoutAction( PduIdType RxPduId )
 Description      : Service to execute rx-signalGroup timeout action
 Parameter        : RxPduId - Internal Rx-IPdu Id
 Return value     : true - if any Gw-signal/signalGroup are updated, otherwise return false.
 *********************************************************************************************************************/
#if defined(COM_RX_SIGNALGROUP) && defined(COM_RxIPduTimeout)
LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_IPduBasedSigGrpTimeoutAction( VAR(PduIdType, AUTOMATIC)   RxPduId )
{
    Com_RxIpduConstPtrType                  RxIPduConstPtr;
#ifdef COM_RX_SIGNALGROUP
    Com_RxSigGrpConstPtrType                RxSigGrpConstPtr;
#if defined(COM_SIGNALGROUPGATEWAY) || (defined(COM_RxFilters) && defined(COM_F_MASKEDNEWDIFFERSOLD))
    Com_RxSigGrpRamPtrType                  RxSigGrpRamPtr;
#endif
#endif
    VAR(uint16_least, AUTOMATIC)            Idx_SigGrp_ui;
    /* updated any timed out gateway rx-signal groups? */
    VAR(boolean, AUTOMATIC)                 isGwSigUpdated_b;

    isGwSigUpdated_b = COM_FALSE;

    RxIPduConstPtr   = COM_GET_RX_IPDU_CONSTDATA(RxPduId);

    /* Set the signal group flags to indicate timeout
     * When the signal group is read using function Com_ReceiveSignalGroup(), if signal group is timed
     * out then either previous value or init value is returned based on the action configured
     */
    RxSigGrpConstPtr = COM_GET_RXSIGGRP_CONSTDATA(RxIPduConstPtr->FirstRxSigGrp_Index);

#if defined(COM_SIGNALGROUPGATEWAY) || (defined COM_RxFilters && defined COM_F_MASKEDNEWDIFFERSOLD)
    RxSigGrpRamPtr   = &COM_GET_RXSIGGRPFLAG(RxIPduConstPtr->FirstRxSigGrp_Index);
#endif
    for (Idx_SigGrp_ui = RxIPduConstPtr->No_Of_SigGrp_Ref; Idx_SigGrp_ui != 0u; Idx_SigGrp_ui--)
    {
        /* Signal Groups with update-bit have seperate timeout handling
         * Signal Groups without update-bit are marked as timed out, when IPdu times out.
         */
#ifdef COM_RxSigGrpUpdateBit
        if (Com_GetValue(RXSIGGRP,_UPDBITCONF,RxSigGrpConstPtr->rxSignalGrpFields) == COM_FALSE)
#endif
        {
            /* Mark the SignalGroup without update-bit as times out,
             * if the SignalGroup TimeoutAction is configured as COM_REPLACE, replace its GroupSignal
             * shadow buffers with SignalInitValues */
            if (Com_GetValue(RXSIGGRP,_TOACTION,RxSigGrpConstPtr->rxSignalGrpFields))
            {
                /* At timeout,Replace group signals in the signal group with Initial values */
                Com_Prv_SigGrpReplaceToInit( RxSigGrpConstPtr, RxIPduConstPtr->MainFunctionRef );
            }
#ifdef COM_SIGNALGROUPGATEWAY
            /* This part of code updates the Rx Gateway queue If the signal group is to be updated
             * into signalgroup buffer by one of the below means
             * 1. Reception of Ipdu and thereby signal update after update bit processing
             */
            if (Com_GetValue(RXSIGGRP,_ISGWSIGGRP,RxSigGrpConstPtr->rxSignalGrpFields) != COM_FALSE)
            {
                /* If the signal is recieved first time after the last call of
                 * Com_MainfunctionRouteSignals then
                 * 1. The fill bit per signal has to be set
                 * 2. Queue entry has to be done for the signal
                 * For the further receptions of the signal, Queue and signal fill bit are not set */
                Com_SetRamValue(RXSIGGRP,_SIGNALFILLBIT,RxSigGrpRamPtr->rxSigGrpRAMFields,COM_TRUE);

                /* Flag will tell if any signalGroups in the Ipdu are updated */
                isGwSigUpdated_b = COM_TRUE;
            }
#endif /* #ifdef COM_SIGNALGROUPGATEWAY */

#if defined (COM_RxFilters) && defined (COM_F_MASKEDNEWDIFFERSOLD)
            /* [SWS_Com_00793] For a signal with a configured reception filter MASKED_NEW_DIFFERS_MASKED_OLD,
             * the AUTOSAR COM module shall treat the first value received for this signal after a reception deadline
             * monitoring timeout occurred for this signal the same way as if the value has passed
             * the filter criteria. */
            Com_SetRamValue(RXSIGGRP,_DMFILTERING,RxSigGrpRamPtr->rxSigGrpRAMFields,COM_TRUE);
#endif /* #if defined (COM_RxFilters) && defined (COM_F_MASKEDNEWDIFFERSOLD) */
        }

        RxSigGrpConstPtr++;
#if defined(COM_SIGNALGROUPGATEWAY) || (defined (COM_RxFilters) && defined (COM_F_MASKEDNEWDIFFERSOLD))
        RxSigGrpRamPtr++;
#endif
    }

    return isGwSigUpdated_b;

} /* End of Com_Prv_IPduBasedSigGrpTimeoutAction */
#endif /* #if defined(COM_RX_SIGNALGROUP) && defined(COM_RxIPduTimeout) */


#ifdef COM_RxSigUpdateTimeout
/**********************************************************************************************************************
 Function name    : Com_Prv_SigBasedTimeoutMonitoring
 Syntax           : boolean Com_Prv_SigBasedTimeoutMonitoring( PduIdType RxPduId )
 Description      : Service to perform timeout processing for rx-Signal with update-bit & timeout
 Parameter        : RxPduId - Internal Rx-IPdu Id
 Return value     : true - if any Gw-signal/signalGroup are updated, otherwise return false.
 *********************************************************************************************************************/
LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_SigBasedTimeoutMonitoring( VAR(PduIdType, AUTOMATIC)  RxPduId )
{
    Com_RxIpduConstPtrType                                      RxIPduConstPtr;
    Com_RxSigConstPtrType                                       RxSigConstPtr;
#if (defined(COM_SIGNALGATEWAY) || (defined (COM_RxFilters) && defined (COM_F_MASKEDNEWDIFFERSOLD)))
    Com_RxSigRamPtrType                                         RxSigRamPtr;
#endif
    P2CONST(Com_SignalTimeoutInfo, AUTOMATIC, COM_APPL_CONST)   SigTimeOutConfigPtr;
    P2VAR(uint16, AUTOMATIC, COM_APPL_DATA)                     SigTimeOutTicksPtr;
    VAR(uint16_least, AUTOMATIC)                                NoOfSigOrSigGrp_ui;
    VAR(uint16_least, AUTOMATIC)                                Idx_Sig_ui;
    VAR(Com_MainFuncType,AUTOMATIC)                             RxMainFuncId;
#ifdef COM_RxUpdateTimeoutNotify
    VAR(boolean, AUTOMATIC)                                     CallTOSigNotify_b;
#endif
    /* updated any timed out gateway rx-signals? */
    VAR(boolean, AUTOMATIC)                                     isGwSigUpdated_b;

    isGwSigUpdated_b    = COM_FALSE;

    RxIPduConstPtr      = COM_GET_RX_IPDU_CONSTDATA(RxPduId);

    RxMainFuncId        = RxIPduConstPtr->MainFunctionRef;

    /* Get the number of signals with update-bit & configured timeout, within this IPDU */
    NoOfSigOrSigGrp_ui  = RxIPduConstPtr->SignalTimeout_Ref->numWithUpdateBit;
    /* Initialise pointer to Com_SignalTimeoutInfo */
    SigTimeOutConfigPtr = RxIPduConstPtr->SignalTimeout_Ref->TimeoutInfo_Ref;
    /* Initialise pointer to timer */
    SigTimeOutTicksPtr  = RxIPduConstPtr->SignalTimeout_Ref->TimeoutTicks_p;

    for (Idx_Sig_ui = NoOfSigOrSigGrp_ui; Idx_Sig_ui != 0u; Idx_Sig_ui--)
    {
#ifdef COM_RxUpdateTimeoutNotify
        /* Reset the CallTOSigNotify_b flag before processing next signal */
        CallTOSigNotify_b = COM_FALSE;
#endif
        RxSigConstPtr     = COM_GET_RXSIG_CONSTDATA(SigTimeOutConfigPtr->SigId);

#if (defined(COM_SIGNALGATEWAY) || (defined (COM_RxFilters) && defined (COM_F_MASKEDNEWDIFFERSOLD)))
        RxSigRamPtr       = &COM_GET_RXSIGNALFLAG(SigTimeOutConfigPtr->SigId);
#endif
        /* Decrement the timer, if time out is enabled
         * If FirstTimeOut for signal is disabled then timer will be loaded with COM_RXTIMER_MAX (0xFFFF).
         * Hence do not decrement the timer if timer is COM_RXTIMER_MAX.
         */
        SchM_Enter_Com_RxSigToTicks();
        if (((*SigTimeOutTicksPtr) != COM_RXTIMER_MAX) && ((*SigTimeOutTicksPtr) != 0u))
        {
            --(*SigTimeOutTicksPtr);
        }
        /* Signal has timed out */
        if ((*SigTimeOutTicksPtr) == 0x00)
        {
            /* Reload the timer */
            (*SigTimeOutTicksPtr) = SigTimeOutConfigPtr->Timeout;

            /* Now check if the RxTimeout action is = COM_REPLACE */
            if (Com_GetValue(RXSIG,_TOACTION,RxSigConstPtr->rxSignalFields))
            {
                VAR(Com_SigMaxType, AUTOMATIC) RxSigVal;
#if (defined( COM_RXSIG_INT64 ) || defined( COM_RXSIG_FLOAT64SUPP ))
                VAR(uint8,AUTOMATIC)           Type;

                Type     = Com_GetValue(GEN,_TYPE,RxSigConstPtr->General);
#endif
                RxSigVal = (Com_SigMaxType)RxSigConstPtr->Init_Val;

/* FC_VariationPoint_START */
#ifdef COM_RXSIG_FLOAT64SUPP
                if (Type == COM_FLOAT64)
                {
                    /* For float64 signals, RxSigConstPtr->Init_Val holds index to float array
                     * holding init values.*/
                    COM_GET_SIGTYPEFLOAT64_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index) =
                                                         Com_getfloat64InitValue(RxSigVal);
                }
                else
#endif /* #ifdef COM_RXSIG_FLOAT64SUPP*/
/* FC_VariationPoint_END */
                {

#ifdef COM_RXSIG_INT64
                    /* [SWS_Com_00723] The AUTOSAR COM module shall extend the init value
                     * (ComSignalInitValue) of a signal to the size of its ComSignalType.
                     * Init_Val by default will be sign extended only for 32bits.
                     * Currently for COM_SINT64 signal types, if the signal is of Negative,
                     * it is required to perform the sign extension till 64bits explicitly. */
                    RxSigVal = (Type == COM_SINT64) ? (Com_SigMaxType)((sint64)((sint32)RxSigVal)) : RxSigVal;
#endif
                    /* Set the signal with Init value as signal timed out */
                    Com_UpdateRxSignalBuffer(RxSigConstPtr, RxSigVal, RxMainFuncId);
                }
            }

#ifdef COM_RxUpdateTimeoutNotify
            /* Set the signal timeout notification flag, and
             * call TO notification callback outside the lock */
            CallTOSigNotify_b = COM_TRUE;
#endif /* #ifdef COM_RxUpdateTimeoutNotify */

#ifdef COM_SIGNALGATEWAY
            /* This part of code updates the Rx Gateway queue If the signal/Ipdu is timed out */
            if(Com_GetValue(RXSIG,_ISGWSIG,RxSigConstPtr->rxSignalFields) != COM_FALSE)
            {
                /* If the signal is updated after the last call of Com_MainfunctionRouteSignals
                 * because of the signal timeout
                 * 1. The fill bit per signal has to be set
                 * 2. Queue entry has to be done for the signal
                 * For the further receptions of the signal, Queue and signal fill bit are not set*/
                Com_SetRamValue(RXSIG,_SIGNALFILLBIT,RxSigRamPtr->rxSigRAMFields,COM_TRUE);

                /* Flag will tell if any signals in the Ipdu are updated */
                isGwSigUpdated_b = COM_TRUE;
            }
#endif /* #ifdef COM_SIGNALGATEWAY */

#if defined (COM_RxFilters) && defined (COM_F_MASKEDNEWDIFFERSOLD)
            /* [SWS_Com_00793] For a signal with a configured reception filter MASKED_NEW_DIFFERS_MASKED_OLD,
             * the AUTOSAR COM module shall treat the first value received for this signal after a reception deadline
             * monitoring timeout occurred for this signal the same way as if the value has passed the
             * filter criteria. */
            Com_SetRamValue(RXSIG,_DMFILTERING,RxSigRamPtr->rxSigRAMFields,COM_TRUE);
#endif /* #if defined (COM_RxFilters) && defined (COM_F_MASKEDNEWDIFFERSOLD) */
        }
        SchM_Exit_Com_RxSigToTicks();

#ifdef COM_RxUpdateTimeoutNotify
        /* If signal has timed out,Call the timeout notification for the signal */
        if ((CallTOSigNotify_b != COM_FALSE) &&
            (SigTimeOutConfigPtr->TimeOutNotification_Cbk != NULL_PTR))
        {
            SigTimeOutConfigPtr->TimeOutNotification_Cbk();
        }
#endif /* #ifdef COM_RxUpdateTimeoutNotify */

        SigTimeOutConfigPtr++;
        SigTimeOutTicksPtr++;
    } /* End for loop */

    return isGwSigUpdated_b;

} /* End of Com_Prv_SigBasedTimeoutMonitoring */
#endif /* #ifdef COM_RxSigUpdateTimeout */


#ifdef COM_RxSigGrpUpdateTimeout
/**********************************************************************************************************************
 Function name    : Com_Prv_SigGrpBasedTimeoutMonitoring
 Syntax           : boolean Com_Prv_SigGrpBasedTimeoutMonitoring( PduIdType RxPduId )
 Description      : Service to perform timeout processing for rx-SignalGroups with update-bit & timeout
 Parameter        : RxPduId - Internal Rx-IPdu Id
 Return value     : true - if any Gw-signal/signalGroup are updated, otherwise return false.
 *********************************************************************************************************************/
LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_SigGrpBasedTimeoutMonitoring( VAR(PduIdType, AUTOMATIC) RxPduId )
{
    Com_RxIpduConstPtrType                                      RxIPduConstPtr;
    Com_RxSigGrpConstPtrType                                    RxSigGrpConstPtr;
#if defined (COM_SIGNALGROUPGATEWAY) || (defined (COM_RxFilters) && defined (COM_F_MASKEDNEWDIFFERSOLD))
    Com_RxSigGrpRamPtrType                                      RxSigGrpRamPtr;
#endif
    P2CONST(Com_SignalTimeoutInfo, AUTOMATIC, COM_APPL_CONST)   SigTimeOutConfigPtr;
    P2VAR(uint16, AUTOMATIC, COM_APPL_DATA)                     SigTimeOutTicksPtr;
    VAR(uint16_least, AUTOMATIC)                                NoOfSigOrSigGrp_ui;
    VAR(uint16_least, AUTOMATIC)                                Idx_Sig_ui;
    VAR(Com_MainFuncType,AUTOMATIC)                             RxMainFuncId;
#ifdef COM_RxUpdateTimeoutNotify
    /* flag to call the callback functions when the SigGrp times out */
    VAR(boolean, AUTOMATIC)                                     CallTOSigGrpNotify_b;
#endif
    /* updated any timed out gateway rx-signal groups? */
    VAR(boolean, AUTOMATIC)                                     isGwSigUpdated_b;

    isGwSigUpdated_b    = COM_FALSE;

    RxIPduConstPtr      = COM_GET_RX_IPDU_CONSTDATA(RxPduId);
    RxMainFuncId        = RxIPduConstPtr->MainFunctionRef;

    /* Get the number of signal groups with update-bit & configured timeout, within this IPDU */
    NoOfSigOrSigGrp_ui  = RxIPduConstPtr->SignalGrpTimeout_Ref->numWithUpdateBit;
    /* Initialise pointer to Com_SignalTimeoutInfo */
    SigTimeOutConfigPtr = RxIPduConstPtr->SignalGrpTimeout_Ref->TimeoutInfo_Ref;
    /* Initialise pointer to timer */
    SigTimeOutTicksPtr  = RxIPduConstPtr->SignalGrpTimeout_Ref->TimeoutTicks_p;

    for (Idx_Sig_ui = NoOfSigOrSigGrp_ui; Idx_Sig_ui != 0u; Idx_Sig_ui--)
    {
#ifdef COM_RxUpdateTimeoutNotify
        /* Initialise the flag which is used to call the TO notification callback functions */
        CallTOSigGrpNotify_b = COM_FALSE;
#endif

#if defined(COM_SIGNALGROUPGATEWAY) || (defined (COM_RxFilters) && defined (COM_F_MASKEDNEWDIFFERSOLD))
        RxSigGrpRamPtr       = &COM_GET_RXSIGGRPFLAG(SigTimeOutConfigPtr->SigId);
#endif
        /* Decrement the timer, if time out is enabled
         * If FirstTimeOut for signal group is disabled then timer will be loaded with COM_RXTIMER_MAX (0xFFFF).
         * Hence do not decrement the timer if timer is COM_RXTIMER_MAX.
         */
        SchM_Enter_Com_RxSigGrpToTicks();
        if (((*SigTimeOutTicksPtr) != COM_RXTIMER_MAX) && ((*SigTimeOutTicksPtr) != 0u))
        {
            --(*SigTimeOutTicksPtr);
        }
        /* Signal group has timed out */
        if ((*SigTimeOutTicksPtr) == 0x00)
        {
            /* Reload the timer */
            (*SigTimeOutTicksPtr) = SigTimeOutConfigPtr->Timeout;

            RxSigGrpConstPtr      = COM_GET_RXSIGGRP_CONSTDATA(SigTimeOutConfigPtr->SigId);

            /* Once SignalGroup with configured update-bit times out and
             * if the SignalGroup TimeoutAction is configured as COM_REPLACE, replace its GroupSignal
             * shadow buffers with SignalInitValues */
            if (Com_GetValue(RXSIGGRP,_TOACTION,RxSigGrpConstPtr->rxSignalGrpFields))
            {
                /* At timeout,Replace group signals in the signal group with Initial values */
                Com_Prv_SigGrpReplaceToInit( RxSigGrpConstPtr, RxMainFuncId );
            }

#ifdef COM_RxUpdateTimeoutNotify
            /* Set the flag which is used to call callback notifications signal group with
             * update bit times out*/
            CallTOSigGrpNotify_b = COM_TRUE;
#endif /* #ifdef COM_RxUpdateTimeoutNotify */

#ifdef COM_SIGNALGROUPGATEWAY
            /* This part of code updates the Rx Gateway queue If the signal group is to be updated
             *  into signalgroup buffer by one of the below means
             * 1. Reception of Ipdu and thereby signal update after update bit processing
             */
            if(Com_GetValue(RXSIGGRP,_ISGWSIGGRP,RxSigGrpConstPtr->rxSignalGrpFields) != COM_FALSE)
            {
                /* If the signal is recieved first time after the last call of
                 * Com_MainfunctionRouteSignals then
                 * 1. The fill bit per signal has to be set
                 * 2. Queue entry has to be done for the signal
                 * For the further receptions of the signal, Queue and signal fill bit are not set*/
                Com_SetRamValue(RXSIGGRP,_SIGNALFILLBIT,RxSigGrpRamPtr->rxSigGrpRAMFields,COM_TRUE);

                /* Flag will tell if any signals in the Ipdu are updated */
                isGwSigUpdated_b = COM_TRUE;
            }
#endif /* #ifdef COM_SIGNALGROUPGATEWAY */

#if defined (COM_RxFilters) && defined (COM_F_MASKEDNEWDIFFERSOLD)
            /* [SWS_Com_00793] For a signal with a configured reception filter MASKED_NEW_DIFFERS_MASKED_OLD,
             * the AUTOSAR COM module shall treat the first value received for this signal after a reception deadline
             * monitoring timeout occurred for this signal the same way as if the value has passed
             * the filter criteria.*/
            Com_SetRamValue(RXSIGGRP,_DMFILTERING,RxSigGrpRamPtr->rxSigGrpRAMFields,COM_TRUE);
#endif /* #if defined (COM_RxFilters) && defined (COM_F_MASKEDNEWDIFFERSOLD) */
        }
        SchM_Exit_Com_RxSigGrpToTicks();

#ifdef COM_RxUpdateTimeoutNotify
        /* If signal group has timed out,Call the timeout notification for the signal */
        if ((CallTOSigGrpNotify_b != COM_FALSE) &&
            (SigTimeOutConfigPtr->TimeOutNotification_Cbk != NULL_PTR))
        {
            SigTimeOutConfigPtr->TimeOutNotification_Cbk();
        }
#endif /* #ifdef COM_RxUpdateTimeoutNotify */

        SigTimeOutConfigPtr++;
        SigTimeOutTicksPtr++;
    } /* End for loop */

    return isGwSigUpdated_b;

} /* End of Com_Prv_SigGrpBasedTimeoutMonitoring */
#endif /* #ifdef COM_RxSigGrpUpdateTimeout */


#ifdef COM_PROVIDE_IPDU_STATUS
/**********************************************************************************************************************
 Function name    : COM_ProvideRxIpduStatus
 Syntax           : boolean COM_ProvideRxIpduStatus(PduIdType PduId)
 Description      : Service returns the status of Rx I-PDU referenced by PduId.
 Parameter        : PduId -> Rx-Ipdu ID
 Return value     : true - if Ipdu is started, otherwise return false.
 *********************************************************************************************************************/
#define COM_START_SEC_CODE
#include "Com_MemMap.h"
FUNC(boolean,COM_CODE) Com_ProvideRxIpduStatus(VAR(PduIdType, AUTOMATIC) PduId)
{
    VAR(boolean, AUTOMATIC) pduStatus_b;

    /* If the Pdu Id passed is not an Rx Ipdu Id or Ipdu is not started, then status false is returned */
    if (PduId < COM_GET_NUM_RX_IPDU)
    {
        /* If PB variant is selected, then PduId which is passed to this function will be changed
         * to internal Id which is generated through configuration
         * If PC variant is selected, then no mapping table will be used. */

        PduId = COM_GET_RX_IPDU_ID(PduId);

        pduStatus_b = Com_CheckRxIPduStatus((PduIdType)PduId);
    }
    else
    {
        pduStatus_b  = COM_FALSE;
    }

    return(pduStatus_b);

} /* End of Com_ProvideRxIpduStatus */
#define COM_STOP_SEC_CODE
#include "Com_MemMap.h"
#endif /* #ifdef COM_PROVIDE_IPDU_STATUS */
